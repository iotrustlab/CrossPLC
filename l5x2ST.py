#!/usr/bin/env python
import l5x
import itertools
import json
import argparse
import os
import time
import sys
import re

from ordered_set import OrderedSet

from os import walk

#######################################
# TODOs (search for TODO # in code)
#######################################
#
# TODO #1: In our current approach, we only process the main routine, which
#          calls the other routines. Ideally, we would implement the other routines
#          as function calls.
# TODO #2: fix this hack. Right now, certain function calls such as SCL that need to
#          be replaced by setting it to return a value into a structure. These should
#          actually be converted to function blocks and then removed from the
#          associated reserve_words as well
#
# TODO #3: Implement the case for multiple params
#
# TODO #4: optimize this such that we don't have to create conjunctions for all conditionals
#
# TODO #5: replace hack to add TON timers for every FBD_TIMER. This should
#          be autogenerated when a call to TONR is detected
#
# TODO #6: replace OSRI hack with OSRI Function block
#
# TODO #7: replace MSG func and Message Type with function block
#
# TODO #8: Booleans can't be used as conditional statements directly; fix this if
#          it is an incorrect assumption
#
# TODO #9: fix hacky solution to replace bit access.
#
# TODO #10: replace SETD hack with function block
#
# TODO #11: Implement Logix_Status. Right now the MSG function is holding us back
#
# TODO #12: Implement RIO1 support
#
# TODO #13: Replace hacky solution for data type checking
#
# TODO #14: Data structures would be helpful for organization (should have started with them)
#
# TODO #15: Matiec has an issue with multi-line comments. Right now,
#           we have a hacky solution to remove multi-line comments
# TODO #16: Function renaming. Right now, if multiple PLCs declare a
#           function with the same name, only the first declaration is
#           considered. We should make it flexible where the programmer
#           can provide multiple different functions with the same name
# TODO #17: Add support for auxiliary function messages
#######################################
# Constant values
#######################################
auxiliary_functions = {
    "SETD: BOOL":
    "FUNCTION SETD : BOOL\n\tVAR_INPUT\n\t\tSD : DOMINANT_SET;\n\tEND_VAR\n\tSETD := SD.Out;\n\tIF SD.EnableIn THEN\n\t\tIF SD.Set THEN\n\t\t\tSETD:= 1;\n\t\tELSE\n\t\t\tIF SD.Reset THEN\n\t\t\t\tSETD := 0;\n\t\t\tEND_IF;\n\t\tEND_IF;\n\t\nEND_IF;\nEND_FUNCTION",
    "SCL: SCALE":
    "FUNCTION SCL: SCALE\n\tVAR_INPUT\n\t\tscale1  :  SCALE ;\n\tEND_VAR\n\tSCL := scale1;\n\tSCL.Out := (scale1.In -scale1.InRawMin) * ((scale1.InEUMax - scale1.InEUMin)/(scale1.InRawMax - scale1.InRawMin)) + scale1.InEUMin;\n\nEND_FUNCTION",
    "ALM: ALARM":
    "FUNCTION ALM: ALARM\n\tVAR_INPUT\n\t\talm1  :  ALARM ;\n\tEND_VAR\n\tALM := alm1;\n\n\t(* High-high to Low-low Alarms*)\n\t(*HHAlarm*)\n\tIF (alm1.HHAlarm = FALSE) AND (alm1.In >= alm1.HHLimit) THEN\n\t\tALM.HHAlarm := TRUE;\n\tELSIF (alm1.HHAlarm = TRUE) AND (alm1.In < (alm1.HHLimit-alm1.Deadband)) THEN\n\t\tALM.HHAlarm := FALSE;\n\tEND_IF;\n\n\t(*HAlarm*)\n\tIF (alm1.HAlarm = FALSE) AND (alm1.In >= alm1.HLimit) THEN\n\t\tALM.HAlarm := TRUE;\n\tELSIF (alm1.HAlarm = TRUE) AND (alm1.In < (alm1.HLimit-alm1.Deadband)) THEN\n\t\tALM.HAlarm := FALSE;\n\tEND_IF;\n\n\t(*LLAlarm*)\n\tIF (alm1.LLAlarm = FALSE) AND (alm1.In <= alm1.LLLimit) THEN\n\t\tALM.LLAlarm := TRUE;\n\tELSIF (alm1.LLAlarm= TRUE) AND (alm1.In > (alm1.LLLimit+alm1.Deadband)) THEN\n\t\tALM.LLAlarm := FALSE;\n\tEND_IF;\n\n\t(*LAlarm*)\n\tIF (alm1.LAlarm = FALSE) AND (alm1.In <= alm1.LLimit) THEN\n\t\tALM.LAlarm := TRUE;\n\tELSIF (alm1.LAlarm = TRUE) AND (alm1.In > (alm1.LLimit+alm1.Deadband)) THEN\n\t\tALM.LAlarm := FALSE;\n\tEND_IF;\n\t(*TODO: Implement ROC alarms*)\n\nEND_FUNCTION",
    "OSRI: BOOL":
    "FUNCTION OSRI :BOOL\n\tVAR_INPUT	\n\t\tEnableIn  :  BOOL ;\n\t\t	InputBit  :  BOOL ;\n\tEND_VAR\n\tOSRI := 0;\n\tIF InputBit THEN\n\t\tInputBit := 1;\n\t\tOSRI := 1;\n\tEND_IF;\n\nEND_FUNCTION",
    "MSG: MESSAGE":
    "(*The MSG instruction transfers elements of data.*)\nFUNCTION MSG: MESSAGE\n\tVAR_INPUT\n\t\tMsg1  :  MESSAGE ;\n\tEND_VAR\n\t(*Clear the prescan bits*)\n\tMSG := Msg1;\n\tMSG.EW := 0;\n\tMSG.ST := 0;\n\tMSG.DN := 0;\n\tMSG.ER := 0;\n\n\t(*Main flow*)\n\tIF MSG.EN1 = 1 OR (MSG.EW = 0 AND MSG.ST = 0) THEN\n\t\tIF MSG.EN1 = 0 THEN\n\t\t\tMSG.EW := 0;\n\t\t\tMSG.ST := 0;\n\t\t\tMSG.TO1 := 0;\n\t\t\tMSG.DN := 0;\n\t\t\tMSG.ER := 0;\n\t\tEND_IF;\n\n\t\tIF MSG.EW = 0 AND MSG.ST = 0 AND MSG.DN = 0 AND MSG.ER = 0 THEN\n\t\t\t(*TODO: implement block transfer command (BTC)*)\n\t\t\t(*If BTC and (not (module path valid) OR not (module connection))*)\n\t\t\tMSG.ER := 1;\n\t\t\t(*ELSE*)\n\t\t\tMSG.EW := 0;\n\t\t\tMSG.ST := 0;\n\t\t\tMSG.TO1 := 0;\n\t\t\tMSG.DN := 0;\n\t\t\tMSG.ER := 0;\n\t\t\tMSG.EN1 := 1;\n\t\t\t(*TODO: Execute message request*)\n\t\t\tMSG.EW := 1;\n\t\tEND_IF;\n\t(*ELSE, .EN1 bit = 0 AND (EW OR ST = 1)*)\n\tELSE\n\t\tMSG.EN1 := 1;\n\tEND_IF;\n\nEND_FUNCTION"
}

auxiliary_structs = {
    "DOMINANT_SET":
    "TYPE  DOMINANT_SET :\n\tSTRUCT\n\t\tEnableIn: BOOL;\n\t\t	Set : BOOL;\n\t\tReset: BOOL;\n\t\t	EnableOut : BOOL;\n\t\t	Out : BOOL;\n\t\tOutNot : BOOL;\n\t	END_STRUCT;\nEND_TYPE",
    "MESSAGE":
    "TYPE MESSAGE:\n\tSTRUCT\n\t\tFLAGS : INT;\n\t\tERR: INT;\n\t\tEXERR: INT;\n\t\tREQ_LEN: INT;\n\t\tDN_LEN: INT;\n\t\tEW: BOOL;\n\t\tER: BOOL;\n\t\tDN: BOOL;\n\t\tST: BOOL;\n\t\tEN1: BOOL;\n\t\tTO1: BOOL;\n\t\tEN_CC: BOOL;\n\t\tERR_SRC: SINT;\n\t\tDestinationLink: INT;\n\t\tDestinationNode: INT;\n\t\tSourceLink: INT;\n\t\tClass: INT;\n\t\tAttribute: INT;\n\t\tInstance: DINT;\n\t\tLocalIndex: DINT;\n\t\tChannel: SINT;\n\t\tRack: SINT;\n\t\tGroup: SINT;\n\t\tSlot: SINT;\n\t\tPath: STRING;\n\t\tRemoteIndex: DINT;\n\t\tRemoteElement: STRING;\n\t\tUnconnectedTimeOut: DINT;\n\t\tConnectionRate: DINT;\n\t\tTimeoutMultiplier: SINT;\n\t\tConnectedFlag: UINT;\n\t\tDescription: STRING;\n\t\tMessageType: STRING;\n\t\tLocalElement: STRING;\n\t\tAttributeNumber: UINT;\n\t\tLargePacketUsage: BOOL;\n\t\tTargetObject: STRING;\n\t\tCommTypeCode: USINT;\n\t\tRequestedLength: INT;\n\t\tConnectionPath: STRING;\n\t\tCacheConnections: BOOL;\n\t\tDestinationTag: STRING;\n\t\tObjectType: UINT;\n\t\tServiceCode : UINT;\n\tEND_STRUCT;\nEND_TYPE"
}

# Hard-coded Configuration
configuration = "CONFIGURATION Config0\n\tRESOURCE Res0 ON PLC\n\t\tTASK Task1(INTERVAL := T#1s,PRIORITY := 0);\n\t\tPROGRAM Inst0 WITH Task1 : prog0;\n\tEND_RESOURCE\nEND_CONFIGURATION"

#######################################
# Constant values
#######################################
# Comparison Operators:
comparison_operators = [
    "<=",
    ">=",
    "=",
    "<>",
    "<",
    ">",
]

# Logical Operators:
logical_operators = ["NOT", "AND", "&", "XOR", "OR"]

# Arithmetic Operators:
arithmetic_operators = ["-", "+", "**", "*", "/", "MOD"]

# TODO #2: fix this hack. Right now, certain function calls such as SCL that need to
#       be replaced by setting it to return a value into a structure. These should
#       actually be converted to function blocks and then removed from the
#       associated reserve_words as well
inout_funcs_tbr = ["SCL", "ALM"]

duplicate_fbds = ["Duty2_FBD"]
# Main Program name used for current configuration where all routines are
# processed recursively from the Main Program routine (TODO #1)
main_program = "MainProgram"

# RIO Channel data headers:
RIO_channels = ["RIO1:", "RIO2:", "RIO3:", "RIO4:", "RIO5:", "RIO6:"]

# This helper variable will help implement our workaround for bit access.
# We need to use DWORDs for bit manipulation because you can perform
# logical operations. From here, we can first perform all necessary
# operations on the dword and then use a DWORD_TO_* function to convert
# back to the intended type
bit_access_helper = "bit_access_helper"
# reserve words for variable names. I just replace them with arbitrary
# values consistently.
reserve_words = {
    "ON": "ON1",
    "type": "TYPE1",
    "EN": "EN1",
    "SCALE": "scl1",
    "alm":"alarm1",
    "Alarm": "alert",
    "ALARM": "alert",
    "TON": "TON1",
    "R_TRIG": "R_TRIG1",
    "TO": "TO1",
    # These were misspelled words that added inconsistency in
    # struct declarations:
    "SHUTODWN1": "SHUTDOWN1",
    "SHUTODWN2": "SHUTDOWN2",
    "SHUTODWN3": "SHUTDOWN3",
    "SHUTODWN4": "SHUTDOWN4",
    "SHUTODWN5": "SHUTDOWN5",
    "SHUTDOWN": "Shutdown",
    "status": "Status",
    "STATUS": "Status",
    "HTY": "Hty",
    "AVL": "Avl"
}

appended_reserved_words = []

#unimplemented data types, e.g., Allen Bradley types
unimplemented_types = {
    "BIT": "BOOL",
    "TIMER": "TIME"  #This may not be correct, but it's not used
}

#######################################
# Global vars for some of our hacky solutions
#######################################
# FBD_TIMERS
fbd_timers = []
# data type mappings
data_types = {}
fbd_types = {}

# Used to make sure there aren't any duplicate structure decs
struct_names = set()

# Used to make sure there aren't any duplicate variable declarations
var_names = OrderedSet()

# Used to make sure there aren't any duplicate function declarations
fbd_names = set()

# Used for renaming Duplicate functions in the context of a program:
#renamed_fbds= {}
# Also used for renaming. If we rename a function, we need a way of
# seeing where it came from when looking up the tag:
fbd_origin = {}

# Used for renaming Duplicate variables in the context of a program:
#renamed_vars = {}
current_controller = 1
# Also used for renaming. If we rename a variable, we need a way of
# seeing where it came from when looking up the tag:
var_origin = {}

# Also used for renaming. If we rename a struct, we need a way of
# seeing where it came from when looking up the tag:
struct_origin = {}

# Messages to initialize later (TODO #7)
msgs_to_initialize = []

# Used to keep track of any local variables that will be removed from
# global lists once the function block is processed
local_vars_to_remove = []


#######################################
# Function definitions for converting types mismatches
#######################################
# INT to REAL
def int_to_real(rhs, var):
    prog_block = rhs.replace(var, "INT_TO_REAL(" + var + ")")
    return prog_block


# DINT to BOOL
def dint_to_bool(rhs, var):
    l_op_found = False
    for op in logical_operators:
        if op in rhs:
            l_op_found = True
            break
    if not l_op_found:
        # TODO: simple workaround right now; we need to find a more formal conversion, possibly through extraction of final bit
        print "ERROR: if DINT not combined with logical op, we can't convert to BOOL; param = ", rhs
    return rhs


# DINT to TIME
def dint_to_time(rhs, var):
    prog_block = rhs.replace(var, "DINT_TO_TIME(" + var + ")", 1)
    return prog_block


# BOOL to DINT
def bool_to_dint(rhs, var):
    prog_block = rhs.replace(var, "BOOL_TO_DINT(" + var + ")", 1)
    return prog_block

# BOOL to INT
def bool_to_int(rhs, var):
    prog_block = rhs.replace(var, "BOOL_TO_INT(" + var + ")", 1)
    return prog_block

# INT TO BOOL
def int_to_bool(rhs, var):
    prog_block = rhs.replace(var, "INT_TO_BOOL(" + var + ")", 1)
    return prog_block
    
# DINT to REAL
def dint_to_real(rhs, var):
    prog_block = rhs.replace(var, "DINT_TO_REAL(" + var + ")", 1)
    return prog_block

# REAL TO INT
def real_to_int(rhs, var):
    prog_block = rhs.replace(var, "REAL_TO_INT(" + var + ")", 1)
    return prog_block


# REAL TO SINT
def real_to_sint(rhs, var):
    prog_block = rhs.replace(var, "REAL_TO_SINT(" + var + ")", 1)
    return prog_block


# REAL TO DINT
def real_to_dint(rhs, var):
    prog_block = rhs.replace(var, "REAL_TO_DINT(" + var + ")", 1)
    return prog_block


#######################################
# Functions for converting types mismatches
#######################################
type_mismatches = {
    "REALINT": int_to_real,
    "BOOLDINT": dint_to_bool,
    "TIMEDINT": dint_to_time,
    "DINTBOOL": bool_to_dint,
    "REALDINT": dint_to_real,
    "INTREAL": real_to_int,
    "SINTREAL": real_to_sint,
    "DINTREAL": real_to_dint,
    "INTBOOL": bool_to_int,
    "BOOLINT": int_to_bool
}

#######################################
# LL conditional instruction definitions
#######################################


# EQU: check if source A == source B
def equ(params):
    if len(params) != 2:
        print "EQU instruction only takes 2 parameters, not ", len(
            params), ": ", params
        sys.exit(0)
    return "(" + replace_renamed_vars(
        params[0]) + " = " + replace_renamed_vars(params[1]) + ")"


# NEQ: check if source A != source B
def neq(params):
    if len(params) != 2:
        print "NEQ instruction only takes 2 parameters, not ", len(
            params), ": ", params
        sys.exit(0)
    return "(" + params[0] + " <> " + params[1] + ")"


# XIC: examine if bit is on
def xic(params):
    s = "("
    i = 0
    for p in params:
        s = s + replace_renamed_vars(p) + " = 1"
        i = i + 1
        if (i < len(params)):
            s = s + " AND "
    s = s + ")"
    return s


# XIO: examine if bit is off
def xio(params):
    s = "("
    i = 0
    for p in params:
        s = s + "(" + replace_renamed_vars(p) + " = 0)"
        i = i + 1
        if (i < len(params)):
            s = s + " AND "
    s = s + ")"
    return s


# OTE: sets (if rung is true) or clears (if rung is false)
#      a data bit. This func will be called twice as we
#      need to ensure a bit is cleared if an else clause exists
def ote(params, condition):
    if len(params) != 1:
        print "OTE instruction only takes 1 parameter, not ", len(
            params), ": ", params
        sys.exit(0)

    return replace_renamed_vars(params[0]) + " := " + ("1" if condition else
                                                       "0") + ";"


# GSV: get system value
def gsv(params):
    if len(params) != 4:
        print "GSV instruction only takes 4 parameters, not ", len(
            params), ": ", params
        sys.exit(0)
    retval = "GSV("
    count = 0
    if params[0] != "?":
        retval = retval + "ClassName := " + replace_renamed_vars(params[0])
        count = count + 1
    if params[1] != "?":
        if count > 0:
            retval = retval + ", "
        retval = retval + "InstanceName := " + replace_renamed_vars(params[1])
        count = count + 1
    if params[2] != "?":
        if count > 0:
            retval = retval + ", "
        retval = retval + "AttributeName := " + replace_renamed_vars(params[2])
        count = count + 1
    if params[3] != "?":
        if count > 0:
            retval = retval + ", "
        retval = retval + "Dest := " + replace_renamed_vars(params[3])
        count = count + 1
    retval = retval + ");\n"
    return retval


# SSV: set system value
def ssv(params):
    if len(params) != 4:
        print "SSV instruction only takes 4 parameters, not ", len(
            params), ": ", params
        sys.exit(0)
    return "SSV(" + replace_renamed_vars(
        params[0]) + "," + replace_renamed_vars(
            params[1]) + "," + replace_renamed_vars(
                params[2]) + "," + replace_renamed_vars(params[3]) + ");"


# JSR: Jump to subroutine. This is typically invoked by the mainroutine.
#      We will just simply process the block for the called subroutine
#      and replace the JSR call with the associated ST routine
def jsr(params, prj, tab):
    s = ""
    i = 0
    #TODO #3: Implement the case for multiple params
    #for p in params:
    #s = s+p
    #i = i+1
    #if i < len(params):
    #s = s+", "
    s = s + tab + "\n(**JSR to " + params[0] + " Routine**)\n"
    s = s + process_routine(prj.programs[main_program].routines[params[0]],
                            prj, tab)
    return s
    #return "JSR("+s+");"


# OTL: output latch; sets data bit true if rung condition true
def otl(params):
    if len(params) != 1:
        print "OTL instruction only takes 1 parameter, not ", len(
            params), ": ", params
        sys.exit(0)
    return replace_renamed_vars(params[0]) + " := 1;"


# OTU: output unlatch; clears data bit if rung condition true
def otu(params):
    if len(params) != 1:
        print "OTU instruction only takes 1 parameter, not ", len(
            params), ": ", params
        sys.exit(0)
    return replace_renamed_vars(params[0]) + " := 0;"


# CLR: clear all the bits of a destination
def clr(params):
    if len(params) != 1:
        print "CLR instruction only takes 1 parameter, not ", len(
            params), ": ", params
        sys.exit(0)
    return replace_renamed_vars(params[0]) + " := 0;"


# NOP instruction
def nop(params):
    return ""


# TON: Timer on delay
def ton(params, enable):
    pre = params[0] + ".PRE := " + replace_renamed_vars(params[1]) + ";\n"
    pre = format_time_line(pre, replace_renamed_vars(params[0]))
    if enable == True:
        enable = "TRUE"
    tenable = replace_renamed_vars(
        params[0]) + ".TimerEnable := " + enable + ";\n"
    tenable = format_time_line(tenable, replace_renamed_vars(params[0]))
    tonr = "TONR(" + replace_renamed_vars(params[0]) + ");"
    tonr = format_time_line(tonr, replace_renamed_vars(params[0]))
    return pre + tenable + tonr


# MOV: move instruction; same as assignment in ST
def mov(params):
    if len(params) != 2:
        print "MOV instruction only takes 2 parameters, not ", len(
            params), ": ", params
        sys.exit(0)
    return replace_renamed_vars(params[1]) + " := " + replace_renamed_vars(
        params[0]) + ";"


# COP: copy file instruction; same as assignment in ST
def cop(params):
    if len(params) != 3:
        print "COP instruction only takes 3 parameters, not ", len(
            params), ": ", params
        sys.exit(0)
    return "COP(" + replace_renamed_vars(
        params[0]) + "," + replace_renamed_vars(
            params[1]) + "," + replace_renamed_vars(params[2]) + ");"


# MSG: reads or writes a  block of data to another module on a network.
#      For our setup, we comment out the messages. If the message
#      involved a write to a remote PLC's data table, we just do a
#      direct write (since all of the variables will be in the same
#      program context)
def msg(params):
    if len(params) != 1:
        print "MSG instruction only takes 1 parameter, not ", len(
            params), ": ", params
        sys.exit(0)
    return params[0] + " := MSG(" + params[0] + ");\n"


# MUL:
def mul(params):
    if len(params) != 3:
        print "MUL instruction only takes 3 parameters, not ", len(
            params), ": ", params
        sys.exit(0)
    return params[2] + " := " + params[0] + " * " + params[1] + ");"


#######################################
# LL conditional instruction definitions
#######################################
cond_funcs = {"EQU": equ, "NEQ": neq, "XIC": xic, "XIO": xio}
reg_funcs = {
    "COP": cop,
    "CLR": clr,
    "GSV": gsv,
    "JSR": jsr,
    "MOV": mov,
    "MSG": msg,
    "MUL": mul,
    "NOP": nop,
    "OTE": ote,
    "OTL": otl,
    "OTU": otu,
    "SSV": ssv,
    "TON": ton
}


#######################################
# class for Used to store FBD Instance params
#######################################
class FBDInstance:
    def __init__(self, name, ftype):
        self.fbd_instance_members = {}
        self.func_params = {}
        self.name = name
        self.ftype = ftype

    def __str__(self):
        ret = self.ftype + "FBDInstance:\n\tName: " + self.name + "\n"
        ret = ret + "\tParams:\n"
        for p in self.fbd_instance_members:
            ret = ret + "\t\t{" + p + " : " + self.fbd_instance_members[p] + "}\n"
        return ret


#######################################
# class for Generated ST File
#######################################
class STFile:
    def __init__(self, struct_decs, func_decs, var_decs, prog_block,
                 description):
        self.description = "(**********************)\n(* " + description + "*)\n(**********************)\n"
        self.struct_decs = self.description + struct_decs
        self.func_decs = self.description + func_decs
        self.var_decs = self.description + var_decs
        self.prog_block = self.description + prog_block

    def __str__(self):
        var_decs = "PROGRAM prog0\n\tVAR\n" + self.var_decs + "\n\tEND_VAR"
        prog_block = self.prog_block + "\nEND_PROGRAM\n" + configuration
        return self.struct_decs + self.func_decs + var_decs + prog_block

    def add_st_content(self, st_file):
        self.struct_decs = self.struct_decs + st_file.struct_decs
        self.func_decs = self.func_decs + st_file.func_decs
        self.var_decs = self.var_decs + st_file.var_decs
        self.prog_block = self.prog_block + "\n" + st_file.prog_block


#######################################
# class for Ladder Logic functions
#######################################
class LLFunc:
    def __init__(self, fname, params):
        self.fname = fname
        self.params = params.split(",")
        #Check if params use any reserved words:
        i = 0
        for word in reserve_words.keys():
            i = 0
            for param in self.params:
                if word in param:
                    self.params[i] = re.sub(r"\b%s:" % word,
                                            reserve_words[word] + ":",
                                            self.params[i])
                    self.params[i] = re.sub(r"\b%s;" % word,
                                            reserve_words[word] + ";",
                                            self.params[i])
                    self.params[i] = re.sub(r"\b%s\s" % word,
                                            reserve_words[word] + " ",
                                            self.params[i])
                    self.params[i] = re.sub(r"\b%s\." % word,
                                            reserve_words[word] + ".",
                                            self.params[i])
                    self.params[i] = re.sub(r"\([\s]*?%s[\s]*?\)" % word,
                                            "(" + reserve_words[word] + ")",
                                            self.params[i])

                i = i + 1
        if fname in cond_funcs:
            self.conditional = True
        else:
            self.conditional = False


#######################################
# Functions for Ladder Logic Processing
#######################################


# Prepare the rung text to easily iterate through the functions and
# parallel instructions. Commas are used to separate both function
# parameters and function calls. We introduce semicolons to separate
# disjunct function calls to easily interpret a rung
def format_rung_text(text):
    formatted = text.replace(' ', '')
    start = 0
    #print "Pre-formatedd String: ",formatted
    #ensure we only replace commas that separate function calls
    offset = formatted.find("(")
    while (offset != -1):
        formatted = formatted[:start] + formatted[start:offset].replace(
            ",", ";").replace('[', '<').replace(']', '>') + formatted[offset:]
        start = formatted[offset:].find(")") + offset
        offset = formatted[start:].find("(")
        if offset != -1:
            offset = offset + start
    if start != -1:
        formatted = formatted[:start] + formatted[start:].replace(']', '>')
    #print "Post-formatting: ", formatted
    return formatted


def process_function(func, params):
    return LLFunc(func, params)


def process_sequential_function_calls(sequence):
    #print  "\n\tSequence:", sequence
    tokenized = sequence.replace(' ', '').replace("(", ' ').replace(
        ")", ' ').split()

    #print "\tLen : ",len(tokenized)

    func_list = []
    if (len(tokenized) == 1):
        func_list.append(
            process_function(tokenized[0].replace(',', '').replace(' ', ''),
                             ""))
    else:
        for i in xrange(0, len(tokenized) - 1, 2):
            func_list.append(
                process_function(tokenized[i].replace(',', '').replace(
                    ' ', ''), tokenized[i + 1]))
        #print "\n\t Func list: "
        #for f in func_list:
        #print f.fname,"(",f.params,")"

    return func_list


def process_rung_instructions(text):
    instr_list = []
    tokenized = text.replace(' ', '').replace('<', ' ').replace('>',
                                                                ' ').split(' ')
    for block in tokenized:
        seq_blocks = block.split(";")
        #the following list will have a len > 1 for disjunctions
        disj_list = []
        for sequence in seq_blocks:
            flist = process_sequential_function_calls(sequence)
            if flist:
                disj_list.append(flist)
        if disj_list:
            instr_list.append(disj_list)
    #print "Instruction list: \n",instr_list
    return instr_list


def decrement_tab(tab):
    return tab.replace("\t", "", 1)


def process_instruction_list(instr_list, prj, t):

    # the first disj_list is going to be the conditional statements;
    # if only one exists then it will just be a regular
    # statement. However, there may be conditional instrs within
    # the regular statements
    s = ""
    tab = t

    # used to keep track if a conditional statement is actually
    # used. Important when generating proper OTE generation
    conditional_statement = False

    # keep track of the OTE functions in a list for the else
    # clause
    ote_funcs = []

    offset = 0

    # check if there is a conditional rung
    if (len(instr_list) > 1):
        conditional_statement = True
        s = "IF ("
        i = 0
        for flist in instr_list[0]:
            j = 0
            for f in flist:
                if not f.conditional:
                    print "There shouldn't be a non-conditional instr at the beginning of a rung"
                    sys.exit(0)
                s = s + cond_funcs[f.fname](f.params)
                j = j + 1
                if j < len(flist):
                    s = s + " AND "
            i = i + 1
            if i < len(instr_list[0]):
                s = s + " OR "
        s = s + ") THEN\n"
        tab = tab + "\t"

    # Process all normal instructions for second instr_list
    #TODO #4:
    for flist in instr_list[(1 if (conditional_statement
                                   and len(instr_list) > 1) else 0)]:

        # We will accumulate all conditions required for the rung to be true
        # in order to execute each instruction
        conditional_func_list = []
        for f in flist:
            if f.conditional:
                conditional_func_list.append(f)
            else:
                if conditional_func_list:
                    s = s + tab + "IF ("
                    i = 0
                    for cf in conditional_func_list:
                        s = s + cond_funcs[cf.fname](cf.params)
                        i = i + 1
                        if i < len(conditional_func_list):
                            s = s + " AND "
                    s = s + ") THEN\n"
                    tab = tab + "\t"
                # If the function is OTE, we need to add additional param for case where rung cond is true
                if f.fname == "OTE":
                    s = s + tab + reg_funcs[f.fname](f.params, True) + "\n"
                # For a JSR, we need to pass the prj context:
                elif f.fname == "JSR":
                    s = s + reg_funcs[f.fname](f.params, prj, tab) + "\n"
                # If the function is TON, we need to add the the enable bit
                elif (f.fname == "TON"):
                    if len(instr_list) > 1:
                        s = s + tab + reg_funcs[f.fname](
                            f.params, instr_list[0][0][0].params[0]) + "\n"
                    # If there is no conditional statement, the rung condition will always be true
                    else:
                        s = s + tab + reg_funcs[f.fname](f.params, True) + "\n"
                # Process functions that don't require additional params
                else:
                    s = s + tab + reg_funcs[f.fname](f.params) + "\n"
            if conditional_func_list and not f.conditional:
                if f.fname == "OTE":
                    s = s + tab.replace("\t", "", 1) + "ELSE \n"
                    s = s + tab + reg_funcs[f.fname](f.params, False) + "\n"
                tab = decrement_tab(tab)
                s = s + tab + "END_IF;\n"

        if conditional_func_list:
            tab = decrement_tab(tab)

    # process any functions that require action if the rung condition is false
    if conditional_statement and len(instr_list) > 1:
        s = s + "ELSE \n"
        for flist in instr_list[1]:
            for f in flist:
                if f.fname == "OTE":
                    s = s + tab + reg_funcs[f.fname](f.params, False) + "\n"
        s = s + "END_IF;\n"

    return s


def process_rung(rung_text, prj, tab):
    #If a bracket appears, parallel sequence of function calls are separated by commas
    # print "\tFull String: ",rung_text

    # For MSG commands, we simply comment these out as messages will be
    # handled in another fashion:
    if "MSG(" in rung_text:
        return "(* Commented out MSG Line*)\n"
    formatted_text = format_rung_text(rung_text)
    instr_list = process_rung_instructions(formatted_text)

    s = process_instruction_list(instr_list, prj, tab)
    # We only format rungs that aren't going to be processed as separate
    # routines

    return s


#######################################
# Function for Processing function block diagrams
#######################################
# Process FBD
def process_fbd(fbd, prj, tab):
    prog_block = ""

    fbd_instances = []
    # For the wiring of FBDs
    input_refs = {}
    output_refs = {}
    addon_refs = {}
    in_wires = {}
    out_wires = {}
    
    for line in fbd.sheets:
        for child in fbd.sheets[line].blocks.child_elements:

            if child.tagName == "AddOnInstruction":

                # We first set the struct members to initial values (if they exist).
                # We later prune this as MatIEC only supports initialization of
                # input variables
                fbd_instance = FBDInstance(child.attributes['Operand'].value,
                                           child.attributes['Name'].value)
                # Store data type for struct:
                data_types[fbd_instance.name] = fbd_instance.ftype
                addon_refs[child.attributes['ID'].value] = child.attributes[
                    'Operand'].value
                for node in prj.controller.tags.members[
                        fbd_instance.name].childNodes:
                    if node.nodeType == 1:
                        for struct in node.childNodes:
                            if struct.nodeType == 1:
                                for struct_member in struct.childNodes:
                                    if struct_member.nodeType == 1:
                                        member = struct_member.getAttribute(
                                            "Name")
                                        if member in reserve_words:
                                            member = reserve_words[member]
                                        fbd_instance.fbd_instance_members[
                                            member] = struct_member.getAttribute(
                                                "Value")
                                        ftype = fbd_instance.ftype
                                        if ftype in duplicate_fbds:
											ftype = fbd_instance.ftype + `current_controller`
                                        # Store data type for this variable:
                                        data_types[(
                                            fbd_instance.name + "." +
                                            member).lower()] = data_types[(
                                                ftype + "." +
                                                member).lower()]

                #We will now add all of the parameters for the function to a map so that we add the params in a consistent order
                #for member in fbd_instance_members.keys():
                #func_params[member] = fbd_instance + "." + member
                # adding additional inout params to func_params
                for inoutparam in child.childNodes:
                    if inoutparam.nodeType == 1:
                        # print "Name: "+replace_renamed_vars(inoutparam.getAttribute("Name"))+"; arg = "+replace_renamed_vars(inoutparam.getAttribute("Argument"))
                        fbd_instance.func_params[inoutparam.getAttribute(
                            "Name")] = inoutparam.getAttribute("Argument")
                fbd_instances.append(fbd_instance)
            elif child.tagName == "ORef":
                # Get the ID and Operand of the wire description
                output_refs[child.attributes['ID'].value] = child.attributes[
                    'Operand'].value
            elif child.tagName == "IRef":
                # Get the ID and Operand of the wire description. It requires the opposite lookup configuration of Orefs
                input_refs[child.attributes['ID'].value] = child.attributes[
                    'Operand'].value
            elif child.tagName == "Wire":
                # Assign either
                if "ToParam" in child.attributes.keys():
                    in_wires[addon_refs[child.attributes["ToID"].value] + "." +
                             child.attributes["ToParam"]
                             .value] = child.attributes["FromID"].value
                elif "FromParam" in child.attributes.keys():
                    out_wires[
                        child.attributes["ToID"].
                        value] = addon_refs[child.attributes["FromID"].
                                            value] + "." + child.attributes["FromParam"].value

        for fbd_instance in fbd_instances:
            i = 0
            # add function params in consistent order (see how functions are generated):
            inparams = {}
            outparams = {}
            inoutparams = {}
            for child in prj.addons[fbd_instance.ftype].get_child_element(
                    "Parameters").childNodes:
                if child.nodeType == 1:

                    # TODO: do we still need all of this? We can probably delete everything outside of the InOut assignments
                    ############################
                    if child.getAttribute("Usage") == "Input":
                        inparams[child.getAttribute(
                            "Name")] = child.getAttribute("DataType")
                    elif child.getAttribute("Usage") == "Output":
                        outvar = child.getAttribute("Name")
                        outparams[outvar] = child.getAttribute("DataType")
                        # Delete any initializations of output variables
                        if child.getAttribute(
                                "Name"
                        ) in fbd_instance.fbd_instance_members.keys():
                            del fbd_instance.fbd_instance_members[
                                child.getAttribute("Name")]
                    elif child.getAttribute("Usage") == "InOut":
                        inoutvar = child.getAttribute("Name")
                        inoutparams[inoutvar] = child.getAttribute("DataType")
                        # Delete any initializations of output variables
                        if child.getAttribute(
                                "Name"
                        ) in fbd_instance.fbd_instance_members.keys():
                            del fbd_instance.fbd_instance_members[
                                child.getAttribute("Name")]
                    else:
                        print "Invalid param usage: ", child.getAttribute(
                            "Usage")
                        exit()
                        ##########################
            fbd_instance.name = fbd_instance.name

            #add initial data structure assignments
            for member in fbd_instance.fbd_instance_members.keys():
                assignment = fbd_instance.fbd_instance_members[member]
                varname = fbd_instance.name + "." + member
                # If this fbd member instance is wired, we should look up the wire configuration
                if varname in in_wires.keys():
                    assignment = input_refs[in_wires[varname]]
                prog_block = prog_block + format_ST_line(
                    tab + fbd_instance.name + "." + member + " := " +
                    assignment + ";\n")

            #start function call:
            prog_block = prog_block + tab + fbd_instance.name + "("

            # enumerate inout params:
            i = 0
            for param in inoutparams.keys():
                if param not in fbd_instance.func_params.keys():
                    continue
                prog_block = prog_block + format_ST_line(
                    tab + "\t" + param + " := " +
                    fbd_instance.func_params[param])
                #prog_block = prog_block + tab + "\t"+fbd_instance.func_params[param]
                i = i + 1
                if i < len(inoutparams.keys()):
                    prog_block = prog_block + ",\n"
            prog_block = prog_block + tab + ");\n"

        # Now we assign any wired output variables:
        for owire in out_wires:
            prog_block = prog_block + format_ST_line(
                tab + "\t" + output_refs[owire] + " := " + out_wires[owire] +
                ";\n")

    return prog_block


#######################################
# Functions for Processing ST Routines
#######################################


# Formats all cases when a timer is found in the ST line (TODO #5)
def format_time_line(line, t):
    st_line = line
    timer = t
    if timer in reserve_words.keys():
        timer = reserve_words[t]
    #Make sure we format the time correctly (if PRE is set):
    if timer + ".PRE" in line:
        tokenized = st_line.replace(' ', '').replace(";", '').split(':=')
        #Make sure .PRE is on left side of assignment
        if len(tokenized
               ) == 2 and ".PRE" in tokenized[0] and tokenized[1].isdigit():
            #print "Before: ",st_line
            st_line = tokenized[0] + " :=t#" + tokenized[1].replace(
                ";", '').replace(' ', '') + "ms;\n"
            #print "After: ",st_line
    #Replace TONR call with call to associated TON timer that was generated (see TODO #5)
    #elif
    if "TONR" in line:
        #Comment out previous TONR call for safe-keeping
        #st_line = "(*"+st_line+"*)\n"

        # Call associated TMR object:
        st_line = timer + "_TMR(IN := " + timer + ".TimerEnable" + ", PT := " + timer + ".PRE" + ");\n"

    # DN of the FBD_TIMER is replaced with Q of the associated TMR object:
    elif timer + ".DN" in line:
        st_line = st_line.replace(timer + ".DN", timer + "_TMR.Q")
    # Reset is translated accordingly (the .IN bit is set to the negation of what the
    # reset was being assigned to. See documentation for equivalence)
    elif timer + ".Reset" in line:
        tokenized = st_line.replace(' ', '').split(':=')
        #Make sure .Reset is on left side of assignment
        if len(tokenized) == 2 and ".Reset" in tokenized[0]:
            st_line = tokenized[0].replace(
                ".Reset", "_TMR.IN") + " := NOT(" + tokenized[1].replace(
                    ";", '') + ");\n"

    return st_line


# Function to replace any bit accesses
def replace_bit_accesses(st_line):
    prog_block = st_line

    # TODO #9: this is a hacky solution to replace bit access.
    # (smaller todo: remove this hack of getting ride of RIOx:.. consideration)
    tmp_line_tok = prog_block.replace("ELSIF", '').replace(":=", ";").replace(
        "IF ",
        '').replace("AND", ';').replace('(', '').replace(')', '').replace(
            "NOT", '').replace("OR", ';').replace("\&", ';').replace(
                "XOR", ';').replace(" THEN", '').replace(' ', '').replace(
                    '\t', '').replace('\n', '').split(';')

    RIO1_replacements = {}
    for word in tmp_line_tok:
        for rio in RIO_channels:
            if rio in word:
                prog_block = prog_block.replace(word, word.replace(".", ";"))
                RIO1_replacements[word] = word.replace(".", ";")
    ba_tokenized = st_line.split(":=")

    #We need to distinguish between bit accesses on LHS vs RHS
    if len(ba_tokenized) == 2:
        #Check LHS:
        bit_accesses = re.search(r"([A-z]*[A-z][A-z][0-9]*)(\.)([0-9][0-9]*)",
                                 ba_tokenized[0])
        if bit_accesses:
            # if we do have a bit access on the LHS, we must first remove the bit access
            # on the LHS. The RHS results is multiplied by 2^(N), where N is the bit
            # access number. This result is then bitwise OR'd with the LHS variable
            repl_str = bit_accesses.group(2) + bit_accesses.group(3)
            truncated_access = ba_tokenized[0].replace(repl_str, '').replace(
                ' ', '').replace('\t', '')
            # We essentially take the ".N" bit access number and set
            bit_to_access = int(bit_accesses.group(3))
            #Because the '**' only works for reals, we will enumerate 2^N:
            two_string = ""
            for i in range(0, bit_to_access):
                two_string = two_string + "*2"

            # RHS value (0 or 1)
            set_value = ba_tokenized[1].replace(";", '').replace(' ',
                                                                 '').replace(
                                                                     '\t', '')
            if not set_value.isdigit():
                set_value = "BOOL_TO_DWORD(" + ba_tokenized[1].replace(
                    ";", '') + ")"
            else:
                set_value = "DINT_TO_DWORD(" + set_value + two_string + ")"

            dtype = data_types[truncated_access.lower()]
            prog_block = bit_access_helper + " :=  " + set_value + " OR " + dtype + "_TO_DWORD(" + truncated_access + ");\n"

            prog_block = prog_block + truncated_access + " := DWORD_TO_" + dtype + "(" + bit_access_helper + ");\n"
            #prog_block + truncated_access + " := (" + ba_tokenized[1].replace(";",'')+")*2**"+bit_accesses.group(3)+" OR ("+truncated_access+");\n"

    # Now we can process the rest of the string for normal bit access.  In this
    # case, because we assume the rest of the equation will be on the RHS,
    # we simply remove the bit access and bitwise AND the variable with
    # 2^(N), where N is the bit access number. TODO: We need to make this
    # work for cases where multiple bit accesses are made:
    orig_line = prog_block
    bit_accesses = re.search(r"([A-z]*[A-z][A-z][0-9]*)(\.)([0-9][0-9]*)",
                             orig_line)
    if bit_accesses:
        repl_str = bit_accesses.group(2) + bit_accesses.group(3)
        token = 0
        if len(ba_tokenized) == 2:
            token = 1
        truncated_access = ba_tokenized[token].replace(repl_str, '').replace(
            '\t', '').replace(';', '').replace(' ', '')
        bit_to_access = int(bit_accesses.group(3))
        bit_to_access
        repl_str = truncated_access + bit_accesses.group(
            2) + bit_accesses.group(3)

        # As before, exponentiation doesn't work for integers
        two_string = "DINT_TO_DWORD(1"
        for i in range(0, bit_to_access):
            two_string = two_string + "*2"
        if two_string != "":
            two_string = two_string + ") AND "

        dtype = data_types[truncated_access.lower()]
        prog_block = bit_access_helper + " := " + two_string + dtype + "_TO_DWORD(" + truncated_access + ");\n"
        prog_block = prog_block + orig_line.replace(
            repl_str, "DWORD_TO_BOOL(" + bit_access_helper + ")")
        bit_accesses = re.search(r"([A-z]*[A-z])(\.)([0-9][0-9]*)", prog_block)
    #Now restore RIO1 vals:
    for rpl in RIO1_replacements.keys():
        prog_block = prog_block.replace(RIO1_replacements[rpl], rpl)

    return prog_block


# Function to replace any reserve words in a ST Line
def replace_reserve_words(st_line):
    prog_block = st_line

    for word in reserve_words.keys():
        #if "SCL :=" in st_line:
        #  print "\tBEFORE: ", prog_block
        #  print "\tWord: ",word
        prog_block = re.sub(r"(\b)(%s)([\+\-:;\s\.><=,/\*])" % word,
                            r"\1%s\3" % (reserve_words[word]), prog_block)
        #prog_block = re.sub(r"\b%s:" % word,reserve_words[word]+":",prog_block)
        #prog_block = re.sub(r"\b%s;" % word,reserve_words[word]+";",prog_block)
        #prog_block = re.sub(r"\b%s\s" % word,reserve_words[word]+" ",prog_block)
        #prog_block = re.sub(r"\b%s\." %word, reserve_words[word]+".",prog_block)
        #prog_block = re.sub(r"\b%s\." %word, reserve_words[word]+".",prog_block)
        prog_block = re.sub(r"\([\s]*?%s[\s]*?\)" % word,
                            "(" + reserve_words[word] + ")", prog_block)
        #if "SCL" in st_line:
        #  print "\tAFTER: ", prog_block

        #st_line = st_line.replace(" "+word+"."," "+reserve_words[word]+".")
    return prog_block


# Function to replace any function block calls that need to be replaced (TODO #2)
def replace_func_calls(st_line):
    prog_block = st_line
    for func in inout_funcs_tbr:
        if func in prog_block:
            tokenized = prog_block.replace(' ', '').replace(';', '').replace(
                ')', '').split('(')
            if len(tokenized) == 2:
                prog_block = prog_block.replace(
                    func, tokenized[1] + " := " + func, 1)
                break
    return prog_block


# Fixes expressions that uses boolean variables as conditions. We
# replace them with checks to see if the bit is high or not. (TODO #8)
def replace_booleans(st_line):
    prog_block = st_line
    if ("IF" in prog_block or "ELSIF" in prog_block) and "THEN" in prog_block:

        tokenized = prog_block.replace("ELSIF", '').replace("IF ", '').replace(
            "AND",
            ';').replace('(', '').replace(')', '').replace("NOT", '').replace(
                "OR", ';').replace("\&", ';').replace("XOR", ';').replace(
                    " THEN", '').replace(' ', '').replace('\t', '').replace(
                        '\n', '').split(';')
        replaced = False
        og = prog_block
        for expr in tokenized:
            if any(x in expr for x in comparison_operators):
                continue
            #Else, no comparison operators were found in the expr, so we have to check if
            #the boolean is = 1
            else:
                replaced = True
                prog_block = prog_block.replace(expr, expr + " = 1")
    return prog_block


# Used to fix type mismatches between the lhs and rhs of an operator
def fix_mismatched_binary_expr(tokenized, oper):
    prog_block = tokenized[0] + oper + tokenized[1]
    #We need to distinguish fix the type mismatches on the RHS
    if len(tokenized) == 2:
        lhs = tokenized[0].replace(';', '')
        rhs = tokenized[1].replace(';', '')
        for operator in logical_operators:
            # NOT is a unary operator
            if operator == "NOT":
                lhs = lhs.replace(operator, '')
                rhs = rhs.replace(operator, '')
            else:
                lhs = lhs.replace(operator, ";")
                rhs = rhs.replace(operator, ";")
        for operator in arithmetic_operators:
            lhs = lhs.replace(operator, ";")
            rhs = rhs.replace(operator, ";")

        for char in [' ', '\t', '\n', ')', '(']:
            lhs = lhs.replace(char, '')
            rhs = rhs.replace(char, '')

        lhs_vars = lhs.split(';')
        rhs_vars = rhs.split(';')
        i = 0
        # Used to see if all rhs terms are digits:
        alldigs = True
        # There should only be one lhs var. Iterate through all rhs vars and
        # make the appropriate conversion
        for rvar in rhs_vars:
            if not rvar.isdigit():
                alldigs = False

            if lhs_vars[0].lower() in data_types.keys():
                if rvar.lower() in data_types.keys():
                    if data_types[lhs_vars[0]
                                  .lower()] != data_types[rvar.lower()]:

                        #print "Mismatch! Calling: ",data_types[lhs_vars[0].lower()]+data_types[rvar.lower()], "; line: ",prog_block
                        tokenized[1] = type_mismatches[
                            data_types[lhs_vars[0].lower()]
                            + data_types[rvar.lower()]](tokenized[1], rvar)
                        #print "returning: ",prog_block
                # Special case for REALS:
                elif data_types[lhs_vars[0].lower()] == "REAL":
                    if rvar.isdigit() and "." not in rvar:
                        tokenized[1] = tokenized[1].replace(rvar, rvar + ".0")
                # Special case for INTs
                elif bool(
                        re.search(r'\b[DS]?INT\b',
                                  data_types[lhs_vars[0].lower()])):
                    if rvar.replace('.', '', 1).isdigit() and "." in rvar:
                        tokenized[1] = type_mismatches[
                            data_types[lhs_vars[0].lower()] + "REAL"](
                                tokenized[1], rvar)

        # Special case for all digits on the right
        if alldigs and lhs_vars[0].lower() in data_types.keys():
            if data_types[lhs_vars[0].lower()] == "TIME":
                tokenized[1] = type_mismatches["TIMEDINT"](
                    tokenized[1], tokenized[1].replace(";", ''))
            i = i + 1
        prog_block = tokenized[0] + oper + tokenized[1]

        return prog_block


# Used to fix type mismatches in an expressoin
def fix_type_mismatches(st_line):
    prog_block = st_line

    #boolean check to see if we need to also process rhs of assignment
    check_rhs = False
    # Type mismatch for assignments
    if ":=" in st_line:
        tokenized = prog_block.split(":=")
        if len(tokenized) == 2:
            prog_block = fix_mismatched_binary_expr(tokenized, ":=")
            # Handle any cases for booleans:
            for op in comparison_operators:
                if op in tokenized[1]:
                    check_rhs = True
    # Very poor implementation for cond exprs that targets specific cases
    if check_rhs or (("IF" in st_line or "ELSIF" in st_line)
                     and "END_IF" not in st_line):

        if check_rhs:
            line = prog_block.split(":=")[1]
        else:
            line = st_line

            for char in [
                    "ELSIF",
                    "THEN",
                    "IF",
            ]:
                line = line.replace(char, '')

        split = ""
        i = 0
        for op in logical_operators:
            split = split + op
            i = i + 1
            if i < len(logical_operators):
                split = split + "|"
        #print "\n\nIF stmt: ",st_line
        for expr in re.split(r'%s' % split, line):
            tmp_expr = expr
            #print "\tOrig expr: ",expr
            tokenized = []
            op = ""
            for cop in comparison_operators:
                for char in [' ', '(', ')']:
                    tmp_expr = tmp_expr.replace(char, '')
                tokenized = tmp_expr.split(cop)
                if len(tokenized) == 2:
                    op = cop
                    break

            if len(tokenized) == 2:
                repl_expr = fix_mismatched_binary_expr(tokenized, op)
                prog_block = prog_block.replace(
                    expr.replace(' ', '').replace('\t',
                                                  '').replace('(', '').replace(
                                                      ')', ''), repl_expr)

    return prog_block


# Function to fix multiline comments issue with MATIEC (TODO #15)
open_comment_count = 0


def fix_multiline_comments(st_line):

    return st_line


# replace a sequence with a sequence:
def replace_sequence(orig, target):
    prog_block = orig
    prog_block = re.sub(r"(\b)(%s)([\+\-:;\s\.><=,/\*])" % target,
                        r"\1%s\3" % (target), prog_block)
    #prog_block  = re.sub(r"\b%s;" % target,target+";",prog_block )
    #prog_block  = re.sub(r"\b%s\s" % target,target+" ",prog_block )
    #prog_block  = re.sub(r"\b%s\." %target, target+".",prog_block )
    prog_block = re.sub(r"\([\s]*%s[\s]*?\)" % target, "(" + target + ")",
                        prog_block)
    prog_block = re.sub(r"([^a-zA-Z\d\_])(%s)([\s]*?\))" % target,
                        r"\1%s\3" % (target), prog_block)
    prog_block = re.sub(r"(\([\s]*?)(%s)([^a-zA-Z\d\_])" % target,
                        r"\1%s\3" % (target), prog_block)
    prog_block = re.sub(r"^%s$" % target, target, prog_block)
    return prog_block


# Used to replace any renamed variables:
def replace_renamed_vars(st_line):
    prog_block = st_line

    for var in var_names:

        if var_origin[var.lower()] in prog_block:

            prog_block = replace_sequence(prog_block, var_origin[var.lower()])
            #print "\n\nReplacing --",var,"-- with ",renamed_vars[var] ," \n\tline : ",prog_block
            #prog_block = re.sub(r"\b%s\b" % var_origin[var],var_origin[var],prog_block )
            #prog_block.replace(var,renamed_vars[var])
        # print "\tReplaced: ",prog_block
    return prog_block


# Used to format a ST line with any necessary replacements for compilation
def format_ST_line(line):
    st_line = line

    for rio in RIO_channels:
        if rio in line:
            return "(*\n " + line + "\n*)"
    printit = False
    if line == "Alarm":
        print "\tBefore: ", line
    #Replace reserve words
    st_line = replace_reserve_words(st_line)
    if line == "Alarm":
        print "\tAfter rw: ", st_line
    #Replace renamed variables:
    st_line = replace_renamed_vars(st_line)
    if line == "Alarm":
        print "\tAfter rv: ", st_line
    # Replace bit accesses:
    st_line = replace_bit_accesses(st_line)

    # replace any function calls (TODO #2)
    st_line = replace_func_calls(st_line)

    # TODO #5:
    for timer in fbd_timers:
        if timer in st_line:
            st_line = format_time_line(st_line, timer)

    # TODO #6: replace OSRI hack with OSRI Function block. We replace the OSRI call with
    # an equivalent implementation for an FBD_ONESHOT struct
    if "OSRI" in st_line:
        tokenized = st_line.replace(' ', '').replace(';', '').replace(
            '(', ' ').replace(')', '').split(' ')
        if len(tokenized) != 2:
            print "ERROR: in the current hacky setup, the replaced OSRI call should be tokenized into 2 tokens: a func call and the parameter; line:\n", tokenized
            exit()
        trig_var = tokenized[1]
        st_line = trig_var + ".OutputBit" + " := OSRI" + "(" + trig_var + ".InputBit" + ", " + trig_var + ".EnableIn" + ");\n"
    # TODO #10: replace SETD hack with function block
    if "SETD" in st_line:
        tokenized = st_line.replace(' ', '').replace(';', '').replace(
            '(', ' ').replace(')', '').split(' ')
        if len(tokenized) != 2:
            print "ERROR: in the current hacky setup, the replaced SETD call should be tokenized into 2 tokens: a func call and the parameter; line:\n", line, tokenized
            exit()
        trig_var = tokenized[1]
        st_line = trig_var + ".Out" + " := SETD" + "(" + trig_var + ");\n"

    # TODO #8: Booleans can't be used as conditional statements directly; fix this if
    #          it is an incorrect assumption

    st_line = replace_booleans(st_line)

    # TODO #13: we use a hacky solution to fix type mismatches that are
    #           consequences of the translation
    st_line = fix_type_mismatches(st_line)

    # TODO #15: Matiec has an issue with multi-line comments. Right now,
    #           we have a hacky solution to remove multi-line comments
    st_line = fix_multiline_comments(st_line)

    # Double check to make sure we didn't add any ";"'s by accident. MATIEC
    # is stingy:
    lines = st_line.split('\n')
    for l in lines:
        if ";" in l.replace(";", '', 1):
            st_line = st_line.replace(l, l.replace(";", '', 1))

    return st_line


def process_routine(routine, prj, tab):
    prog_block = ""
    #Skip Logix status and Inv Checker for now (TODO #11)
    rname = routine.element.attributes["Name"].value
    if (rname == "Logix_Status" or rname == "Inv_Checker"):
        return prog_block
    #print "ROUTINE: ",routine.element.attributes["Name"].value,"Type: ",routine.type
    #ladder logic:
    if (routine.type == "RLL"):
        for rung in routine.rungs:
            st_line = process_rung(routine.rungs[rung].text, prj, tab)
            prog_block = prog_block + st_line
    # FBD Routines
    if (routine.type == "FBD"):
        prog_block = prog_block + process_fbd(routine, prj, tab)

    #ST Routines
    if (routine.type == "ST"):
        for linenode in routine.lines.child_elements:
            if linenode.nodeType == 1:
                for linechild in linenode.childNodes:
                    if linechild.nodeType == 4:
                        # pre-process line in case any modifications are necessary
                        line = format_ST_line(linechild.nodeValue)
                        prog_block = prog_block + tab + line + "\n"

    # replace any reserve words:
    for word in reserve_words.keys():
        prog_block = re.sub(r"\b%s[\s:]" % word, reserve_words[word],
                            prog_block)

    return prog_block


# Process routines
def process_routines(routines, prj):
    prog_block = ""
    for routine in routines:
        prog_block = prog_block + process_routine(routines[routine], prj, "")
    return prog_block


# Process any defined auxiliary structs. This is really just to store
# the data members of each struct into the associated global variables
def process_aux_structs():
    global auxiliary_structs
    dec = ""
    for sd in auxiliary_structs.keys():
        struct_dec = sd
        # Prevent double entries
        if struct_dec in struct_names:
            continue
        struct_origin[struct_dec] = sd
        struct_names.add(struct_dec)

        dec = dec + "TYPE " + struct_dec + ":\n\tSTRUCT\n"
        struct_member_list = {}

        #Add each struct member to fbd_types for data type mapping
        for line in auxiliary_structs[sd].splitlines():
            if "TYPE" in line or "STRUCT" in line or "END_TYPE" in line or "END_STRUCT" in line:
                continue
            else:
                tokenized = line.replace(' ', '').replace('\t', '').split(':')
                if len(tokenized) != 2:
                    print "ERROR: var dec should be tokenized into 2 strings; line: ", line
                    exit()
                var = tokenized[0]
                dtype = tokenized[1]

                if dtype in unimplemented_types.keys():
                    dtype = unimplemented_types[dtype]
                # Make sure dtype isn't renamed fbd
                #if dtype in renamed_fbds.keys():
                #dtype = renamed_fbds[dtype]
                if dtype in fbd_origin.values():
                    dtype = dtype

                # Built in FBD_TIMER differs for one member
                if struct_dec == "FBD_TIMER" and var == "PRE":
                    dtype = "TIME"
                if var in reserve_words.keys():
                    var = reserve_words[var]

                var = var

                struct_member_list[var] = dtype
                dec = dec + "\t\t" + var + " : " + dtype + "\n"
            fbd_types[struct_dec] = struct_member_list
        dec = dec + "\tEND_STRUCT;\nEND_TYPE\n"
    return dec


#######################################
# Module Processing:
#######################################
def process_module_structs(prj):
    struct_decs = ""
    return struct_decs


#######################################
# Generation of Structure Declarations
#######################################
def generate_struct_decs(prj):
    #add structs
    struct_decs = ""
    global fbd_types
    #first include any auxiliary structs that may need to be defined, e.g., built-in AB functions
    struct_decs = struct_decs + process_aux_structs()

    for sd in prj.datatypes:
        sdtype = sd
        # Prevent double entries
        if sdtype in struct_names:
            continue

        struct_names.add(sdtype)
        struct_origin[sdtype] = sd

        struct_decs = struct_decs + "TYPE " + sdtype + ": \n\tSTRUCT\n"
        struct_type_list = {}
        for child in prj.datatypes[sd].child_elements[0].childNodes:
            if child.nodeType == 1:
                var = child.attributes['Name'].value
                dtype = child.attributes['DataType'].value

                if dtype in unimplemented_types.keys():
                    dtype = unimplemented_types[dtype]
                # Make sure dtype isn't renamed fbd
                #if dtype in renamed_fbds.keys():
                #dtype = renamed_fbds[dtype]
                if dtype in fbd_origin.values(
                ) or dtype in struct_origin.values():
                    dtype = dtype
                # Built in FBD_TIMER differs for one member
                if sdtype == "FBD_TIMER" and var == "PRE":
                    dtype = "TIME"
                if var in reserve_words.keys():
                    var = reserve_words[var]

                var = var

                struct_decs = struct_decs + "\t\t" + var + " : " + dtype + ";\n"

                struct_type_list[var] = dtype
        struct_decs = struct_decs + "\n\tEND_STRUCT;\nEND_TYPE\n"
        # Add member types to mapping for this struct (TODO #13)
        fbd_types[sdtype] = struct_type_list

    #add on instruction structs:
    for addon in prj.addons:
        #All add on structs:
        for localTag in prj.addons[addon].child_elements[1].childNodes:
            if localTag.nodeType == 1:
                for ddata in localTag.childNodes:
                    if ddata.nodeType == 1:
                        #ensure correct default data type
                        if (len(ddata.attributes.keys()) > 0):
                            for struct_dec in ddata.childNodes:
                                if struct_dec.nodeType == 1 and len(
                                        struct_dec.childNodes) > 3:
                                    sdtype = struct_dec.attributes[
                                        'DataType'].value
                                    if sdtype in struct_names:
                                        continue
                                    struct_origin[
                                        sdtype] = struct_dec.attributes[
                                            'DataType'].value
                                    struct_names.add(sdtype)

                                    struct_type_list = {}
                                    struct_decs = struct_decs + "TYPE " + sdtype + ": \n\tSTRUCT\n"
                                    for struct_element in struct_dec.childNodes:
                                        if struct_element.nodeType == 1:
                                            var = struct_element.attributes[
                                                'Name'].value
                                            dtype = struct_element.attributes[
                                                'DataType'].value
                                            if sdtype == "FBD_TIMER" and var == "PRE":
                                                dtype = "TIME"
                                            if dtype in fbd_origin.values(
                                            ) or dtype in struct_origin.values(
                                            ):
                                                dtype = dtype
                                            if var in reserve_words.keys():
                                                var = reserve_words[var]

                                            var = var
                                            if dtype in unimplemented_types.keys(
                                            ):
                                                dtype = unimplemented_types[
                                                    dtype]

                                            # Make sure dtype isn't renamed fbd
                                            #if dtype in renamed_fbds.keys():
                                            #dtype = renamed_fbds[dtype]

                                            struct_decs = struct_decs + "\t\t" + var + " : " + dtype + ";\n"
                                            struct_type_list[var] = dtype
                                    struct_decs = struct_decs + "\n\tEND_STRUCT;\nEND_TYPE\n"
                                    fbd_types[sdtype] = struct_type_list

    #create structures to be used by each
    # if addon not in struct_names:
    #   struct_decs = struct_decs + "TYPE "+addon+": \n\tSTRUCT\n"
    #   for param in prj.addons[addon].params.members:
    #     dtype = prj.addons[addon].params.members[param].attributes['DataType'].value
    #     var = param
    #     if var in reserve_words.keys():
    #       var = reserve_words[var]
    #     if dtype in unimplemented_types.keys():
    #       dtype = unimplemented_types[dtype]
    #     struct_decs = struct_decs +  "\t\t"+var+" : "+dtype+";\n"
    #   struct_decs = struct_decs +"\n\tEND_STRUCT;\nEND_TYPE\n";

    # Now we process all Modules:
    struct_decs = struct_decs + process_module_structs(prj)

    return struct_decs


#######################################
# Function block generation (for addon instructions)
#######################################


# Used to process function parameters.
def process_params(params, vartype):
    func_decs = ""
    if len(params) > 0:
        func_decs = func_decs + vartype + "\n"
        for var in params.keys():
            #if var in renamed_vars.keys():
            #var = renamed_vars[var]
            func_decs = func_decs + "\t\t" + var + " : " + params[var] + ";\n"

            var_names.add(var.lower())
            local_vars_to_remove.append(var.lower())
            if params[var] in struct_names:

                for subtype in fbd_types[params[var]].keys():
                    data_types[(var + "." + subtype).lower()] = fbd_types[
                        params[var]][subtype].replace(";", '')
                    var_names.add((var + "." + subtype).lower())
                    local_vars_to_remove.append((var + "." + subtype).lower())
                    var_origin[(var + "." +
                                subtype).lower()] = var + "." + subtype[:-1]
            else:
                data_types[var.lower()] = params[var].replace(";", '')

            #TODO #5:
            if params[var] == "FBD_TIMER":
                func_decs = func_decs + "\t\t" + var + "_TMR: TON;\n"
                fbd_timers.append(var)
            # check if this is a message that should be initialized later (TODO #7)
            elif params[var] == "MESSAGE":
                msgs_to_initialize.append(var)

        func_decs = func_decs + "END_VAR\n"
    return func_decs


# Used to process auxiliary functions
def process_aux_funcs(fbd):
    global reserve_words
    global msgs_to_initialize
    global local_vars_to_remove
    func_decs = ""
    addon = fbd

    # Because this is a function, it will have a return value. If the return
    # value is a struct, we have to be sure to replace the submembers with
    # the renamed values:
    ftokens = fbd.replace(' ', '').split(':')
    if len(ftokens) != 2:
        print "ERROR: Function name must have type: ", fbd
        exit()
    addon = ftokens[0]
    ftype = ftokens[1]
    if addon in fbd_names:
        return func_decs

    fbd_origin[addon] = fbd
    fbd_names.add(addon)

    var_names.add(addon.lower())
    local_vars_to_remove.append(addon)
    var_origin[addon.lower()] = ftokens[0]

    if ftype in struct_origin.values():
        ftype = ftype
        for subtype in fbd_types[ftype].keys():
            data_types[(addon + "." +
                        subtype).lower()] = fbd_types[ftype][subtype].replace(
                            ";", '')
            local_vars_to_remove.append((addon + "." + subtype).lower())
            var_names.add((addon + "." + subtype).lower())
            var_origin[(
                addon + "." + subtype).lower()] = addon + "." + subtype[:-1]
    data_types[addon.lower()] = ftype
    func_decs = func_decs + "FUNCTION " + addon + " : " + ftype + "\n"
    inparams = {}
    outparams = {}
    inoutparams = {}
    localvars = {}

    # We're going to iterate through the lines while storing the var
    # decs.
    # -case 0 for start, 1 for input, 2 for output, 3 for inout, 4 for local,
    #  5 var_dec generation, 6 for code processing
    case = 0
    for line in auxiliary_functions[fbd].split("\n"):

        if "VAR_INPUT" in line:
            case = 1
            continue
        elif "VAR_OUTPUT" in line:
            case = 2
            continue
        elif "VAR_INOUT" in line:
            case = 3
            continue
        elif "END_VAR" in line:
            case = 0
            continue
        elif "VAR" in line:
            case = 4
            continue
        elif "END_FUNCTION" in line:
            break
        elif "FUNCTION" in line:
            continue
        elif case == 0:
            case = 5  #No more var decs, we can move onto var dec generation
        else:
            if case > 0 and case < 5:
                var_dec = line
                for char in [' ', '\t', ';']:
                    var_dec = var_dec.replace(char, '')
                tokens = var_dec.split(':')
                if len(tokens) != 2:
                    print "ERROR: should only have 2 tokens in var dec; line: ", line
                    exit()
                var = tokens[0]
                tag = var
                dtype = tokens[1]

                if dtype in fbd_origin.values(
                ) or dtype in struct_origin.values():
                    dtype = dtype
                if var in reserve_words.keys():
                    var = reserve_words[var]

                var = var

                data_types[var.lower()] = dtype
                var_origin[var.lower()] = tag
                var_names.add(var.lower())

                local_vars_to_remove.append(var.lower())
                if dtype in struct_names:
                    for subtype in fbd_types[dtype].keys():
                        data_types[(var + "." + subtype).lower()] = fbd_types[
                            dtype][subtype].replace(";", '')
                        local_vars_to_remove.append(
                            (var + "." + subtype).lower())
                        var_names.add((var + "." + subtype).lower())
                        var_origin[(var + "." + subtype
                                    ).lower()] = tag + "." + subtype[:-1]
                else:
                    data_types[var.lower()] = dtype.replace(";", '')
                    local_vars_to_remove.append(var.lower())

                if dtype in unimplemented_types.keys():
                    dtype = unimplemented_types[dtype]

                # Store the dtype for this variable in the global context:
                data_types[(addon + "." + var).lower()] = dtype

                if case == 1:
                    inparams[var] = dtype
                elif case == 2:
                    outparams[var] = dtype
                elif case == 3:
                    inoutparams[var] = dtype
                elif case == 4:
                    localvars[var] = dtype

        if case == 5:  # var_dec processing:
            #process inputs
            func_decs = func_decs + process_params(inparams, "VAR_INPUT")

            #process outputs
            func_decs = func_decs + process_params(outparams, "VAR_OUTPUT")

            #process inouts
            func_decs = func_decs + process_params(inoutparams, "VAR_IN_OUT")

            #process localvars
            func_decs = func_decs + process_params(localvars, "VAR")

            case = 6
            #if "SCL2" in addon:
            # print var_names
        if case == 6:  #Code processing
            #if "SCL" in line:
            #  print "\n\nLine before: ",line
            #Replace reserve words
            st_line = replace_reserve_words(line)
            #if "SCL" in line:
            # print "\n\nLine after rw: ",st_line
            #Replace renamed variables:
            st_line = replace_renamed_vars(st_line)
            #if "SCL" in line:
            # print "\n\nLine after rv: ",st_line

            # Replace bit accesses:
            st_line = replace_bit_accesses(st_line)

            st_line = replace_booleans(st_line)

            # TODO #13: we use a hacky solution to fix type mismatches that are
            #           consequences of the translation
            st_line = fix_type_mismatches(st_line)

            func_decs = func_decs + st_line + "\n"

    # Append function name to reserved words to ensure they can't
    # be used as variable names in the future. We are allowed to
    # use them within the context of the function definition
    func_name = fbd.split(":")[0].replace("FUNCTION", '').replace(' ', '')
    reserve_words[func_name] = func_name.lower()+`current_controller`
    #appended_reserved_words.append(func_name)

    func_decs = func_decs + "END_FUNCTION\n"
    # Remove local tags from data type mapping:
    delete_local_var_mappings()

    # For simplicity, we assume auxiliary functions do not have messages
    del msgs_to_initialize[:]

    #print "Func after:\n",func_decs
    return func_decs


def delete_local_var_mappings():
    global local_vars_to_remove
    # Remove local tags from data type mapping:
    for var in local_vars_to_remove:
        if var.lower() in data_types.keys():
            del data_types[var.lower()]
        if var.lower() in var_origin.keys():
            del var_origin[var.lower()]
        if var.lower() in var_names:
            var_names.remove(var.lower())
    del local_vars_to_remove[:]


def remove_appended_reserved_words():
    for word in appended_reserved_words:
        if word in reserve_words:
            del reserve_words[word]


def delete_all_var_mappings():
    data_types.clear()
    var_origin.clear()
    var_names.clear()
    fbd_types.clear()
    del fbd_timers[:]
    struct_names.clear()
    struct_origin.clear()
    del local_vars_to_remove[:]
    del msgs_to_initialize[:]


###########################
def generate_func_decs(prj):
    global auxiliary_functions
    global fbd_timers
    global msgs_to_initialize
    global local_vars_to_remove
    func_decs = ""
    #first include any auxiliary functions that may need to be defined, e.g., built-in AB functions
    for fbd in auxiliary_functions.keys():
        if fbd in fbd_names:
            continue
        func_decs = func_decs + process_aux_funcs(fbd) + "\n"

    for fbd in prj.addons:
        addon = fbd
        if addon in duplicate_fbds:
          addon = fbd + `current_controller`
        if addon in fbd_names:
          continue
        #  If there is a duplicate function name, we simply rename the variable
        #  and map it to be replaced later.
        #while addon in fbd_names:
        #renamed_fbds[fbd] = addon+"_N"
        #addon = renamed_fbds[fbd]
        # Keep track of where this variable name came from:
        fbd_origin[addon] = fbd
        fbd_names.add(addon)

        func_decs = func_decs + "FUNCTION_BLOCK " + addon + "\n"
        inparams = {}
        outparams = {}
        inoutparams = {}
        # This is used to keep track of which function variables are used
        # during the type checking process. They will be removed the
        # the global program context at the end of each function processing
        for child in prj.addons[fbd_origin[addon]].get_child_element(
                "Parameters").childNodes:
            if child.nodeType == 1:
				
                tag = child.getAttribute("Name")
                var = tag
                dtype = child.getAttribute("DataType")

                # Make sure dtype isn't renamed fbd
                #if dtype in renamed_fbds.keys():
                #dtype = renamed_fbds[dtype]
                if dtype in duplicate_fbds:
                    dtype = dtype+`current_controller`
                if var in reserve_words.keys():
                    var = reserve_words[var]
                    tag = reserve_words[tag]

                

                var_origin[var.lower()] = tag
                var_names.add(var.lower())
                data_types[var.lower()] = dtype

                local_vars_to_remove.append(var.lower())

                if dtype in struct_names:
                    for subtype in fbd_types[dtype].keys():
                        data_types[(var + "." + subtype).lower()] = fbd_types[
                            dtype][subtype].replace(";", '')
                        local_vars_to_remove.append(
                            (var + "." + subtype).lower())
                        var_names.add((var + "." + subtype).lower())
                        var_origin[(var + "." + subtype
                                    ).lower()] = var + "." + subtype[:-1]

                else:
                    data_types[var.lower()] = dtype.replace(";", '')
                    local_vars_to_remove.append(var.lower())

                if dtype in unimplemented_types.keys():
                    dtype = unimplemented_types[dtype]

                # Store the dtype for this variable in the global context:
                data_types[(addon + "." + var).lower()] = dtype

                if child.getAttribute("Usage") == "Input":
                    inparams[var] = dtype
                elif child.getAttribute("Usage") == "Output":
                    outparams[var] = dtype
                elif child.getAttribute("Usage") == "InOut":
                    inoutparams[var] = dtype
                else:
                    print "Invalid param usage: ", child.getAttribute("Usage")
                    exit()

        #process inputs
        func_decs = func_decs + process_params(inparams, "VAR_INPUT")
        #process outputs
        func_decs = func_decs + process_params(outparams, "VAR_OUTPUT")
        #process inouts
        func_decs = func_decs + process_params(inoutparams, "VAR_IN_OUT")

        #process local vars:
        if len(prj.addons[fbd_origin[addon]].localtags) > 0:
            func_decs = func_decs + "VAR\n"
            # This will map all variables that use this function to their datatypes
            for child in prj.addons[fbd_origin[addon]].get_child_element(
                    "LocalTags").childNodes:
                if child.nodeType == 1:
                    tag = child.getAttribute("Name")
                    var = tag
                    #if var in renamed_vars.keys():
                    #var = renamed_vars[var]

                    dtype = child.getAttribute("DataType")

                    if dtype in duplicate_fbds:
                        dtype = dtype+`current_controller`
                        print dtype
                    if var in reserve_words.keys():
                        var = reserve_words[var]
                        tag = reserve_words[tag]
                    
                    var = var
                    
                    var_origin[var.lower()] = tag
                    var_names.add(var.lower())
                    data_types[var.lower()] = dtype

                    local_vars_to_remove.append(var.lower())

                    if dtype in struct_names:

                        for subtype in fbd_types[dtype].keys():

                            data_types[(var + "." + subtype).lower(
                            )] = fbd_types[dtype][subtype].replace(";", '')
                            local_vars_to_remove.append(
                                (var + "." + subtype).lower())
                            var_names.add((var + "." + subtype).lower())

                            var_origin[(var + "." + subtype
                                        ).lower()] = var + "." + subtype[:-1]

                    else:
                        data_types[var.lower()] = dtype.replace(";", '')
                    if dtype in unimplemented_types.keys():
                        dtype = unimplemented_types[dtype]

                    #TODO #5:
                    if dtype == "FBD_TIMER":
                        func_decs = func_decs + "\t\t" + var + "_TMR: TON;\n"
                        fbd_timers.append(var)
                    # check if this is a message that should be initialized later (TODO #7)
                    elif dtype == "MESSAGE":
                        msgs_to_initialize.append(var)

                    func_decs = func_decs + "\t\t" + var + " : " + dtype + ";\n"
                    # Map all variables to their types(TODO #13):
                    #if dtype in struct_names:

                    #  for subtype in fbd_types[dtype].keys():
                    #    data_types[(var+"."+subtype).lower()] = fbd_types[dtype][subtype].replace(";",'')
                    ##    local_vars_to_remove.append((var+"."+subtype).lower())
                    #    var_names.add((var+"."+subtype).lower())
                #     var_origin[(var+"."+subtype).lower()] = var+"."+subtype[:-1]
                # else:
                #   data_types[var.lower()] = dtype.replace(";",'')
                #  local_vars_to_remove.append(var.lower())

            func_decs = func_decs + "END_VAR\n"

        #initialize messages (TODO #7)
        func_decs = func_decs + initialize_messages(
            prj.addons[fbd_origin[addon]].localtags.members)

        # now we can add structured text content
        func_decs = func_decs + process_routines(
            prj.addons[fbd_origin[addon]].routines, prj)

        delete_local_var_mappings()

        func_decs = func_decs + "END_FUNCTION_BLOCK\n"

    return func_decs


# Initialize messages with their associated message parameters (TODO #7)
def initialize_messages(tags):
    global msgs_to_initialize
    prog_block = ""
    for msg in msgs_to_initialize:
        for child in tags[var_origin[msg.lower()]].childNodes:
            #Ensure this is a data element
            if child.nodeType == 1:
                for messageParam in child.childNodes:
                    # Ensure this is a messageParameters element
                    if messageParam.nodeType == 1:
                        # We only care about data table reads or writes from PLC to PLC:
                        mType = messageParam.attributes["MessageType"].value
                        description = "(* " + msg + " MSG: " + mType + "*)\n"
                        controller = messageParam.attributes[
                            "ConnectionPath"].value.replace("_CONTROLLER",
                                                            '').replace(
                                                                "P", '')
                        if mType == "CIP Data Table Read":
                            # We assume these elements have the same fbd struct
                            remote_element = messageParam.attributes["RemoteElement"].value + controller
                            local_element = messageParam.attributes[
                                "LocalElement"].value

                            prog_block = description + "(* " + local_element + " := " + remote_element + ";*)\n"
                            # Iterate through all the subtypes and assign each one individually.
                            # Because structs are renamed for every controller, we need to simply
                            # set each member to each other:
                            if remote_element.lower() in data_types.keys(
                            ) and local_element.lower() in data_types.keys():
                                if data_types[remote_element.lower(
                                )] in fbd_types.keys(
                                ) and data_types[remote_element.lower(
                                )] in fbd_types:
                                    for rstype in fbd_types[data_types[
                                            remote_element.lower()]]:
                                        for lstype in fbd_types[data_types[
                                                local_element.lower()]]:
                                            if rstype[:-1] == lstype[:-1]:
                                                prog_block = prog_block + local_element + "." + lstype + " := " + remote_element + "." + rstype + ";\n"

                        elif mType == "CIP Data Table Write":
                            remote_element = messageParam.attributes["RemoteElement"].value + controller
                            local_element = messageParam.attributes[
                                "LocalElement"].value
                            prog_block = description + "(* " + remote_element + " := " + local_element + ";*)\n"
                            # Iterate through all the subtypes and assign each one individually.
                            # Because structs are renamed for every controller, we need to simply
                            # set each member to each other:
                            if remote_element.lower() in data_types.keys(
                            ) and local_element.lower() in data_types.keys():
                                if data_types[remote_element.lower(
                                )] in fbd_types.keys(
                                ) and data_types[remote_element.lower(
                                )] in fbd_types:
                                    for rstype in fbd_types[data_types[
                                            remote_element.lower()]]:
                                        for lstype in fbd_types[data_types[
                                                local_element.lower()]]:
                                            if rstype[:-1] == lstype[:-1]:
                                                prog_block = prog_block + remote_element + "." + rstype + " := " + local_element + "." + lstype + ";\n"

                        #for attribute in messageParam.attributes.keys():

                        # mVal = messageParam.attributes[attribute].value
                        # Certain attributes need to be encapsulated in quotes.
                        # TODO: move these to a global array
                        # if attribute == "MessageType" or attribute == "ConnectionPath" or attribute == "LocalElement" or attribute == "TargetObject" or attribute == "RemoteElement" or attribute == "DestinationTag":
                        #  mVal = "\'"+messageParam.attributes[attribute].value+"\'"
                        #prog_block = prog_block + msg+"."+attribute+" := "+mVal+";\n"
    # Empty msg queue
    del msgs_to_initialize[:]

    return prog_block


#######################################
# Main file parsing routine
#######################################
def parse_l5x_file(l5x_file):

    prj = l5x.Project(l5x_file)
    prog_block = ""
    struct_decs = ""
    func_decs = ""
    var_decs = ""
    global fbd_timers
    global msgs_to_initialize
    #add structures:
    struct_decs = generate_struct_decs(prj)

    #add on instruction functions:
    func_decs = generate_func_decs(prj)

    #Add program variables:
    if len(prj.controller.tags) > 0:
        var_decs = var_decs + "\n\t(*Controller Tags*)\n"

    for mtag in prj.controller.tags.members:
        tag = mtag
        var = tag
        #  If there is a duplicate variable name, we simply renamed the variable
        #  and map it to be replaced later. Each version will be rep
        # while var in var_names:
        #renamed_vars[tag] = var+"_N"
        #var = renamed_vars[tag]
        # Keep track of where this variable name came from:

        # Get the var data type:
        dtype = prj.controller.tags.members[tag].getAttribute('DataType')

        if var in reserve_words.keys():
            var = reserve_words[mtag]
            tag = reserve_words[mtag]

        if var.lower() in var_names:
			continue

        # Make sure dtype isn't renamed fbd
        #if dtype in renamed_fbds.keys():
        #dtype = renamed_fbds[dtype]

        # check if this is a message that should be initialized later
        if dtype == "MESSAGE":
            msgs_to_initialize.append(var)
        #TODO #5:
        if dtype == "FBD_TIMER":
            var_decs = var_decs + "\t\t" + var + `current_controller`+"_TMR : TON;\n"
            fbd_timers.append(var)
            reserve_words[var] = var+`current_controller`
            appended_reserved_words.append(var)
            var = var + `current_controller`

        if dtype in duplicate_fbds:
            dtype = dtype+`current_controller`

        if dtype in unimplemented_types.keys():
            dtype = unimplemented_types[dtype]
        data_types[var.lower()] = dtype.replace(";", '')
        var_origin[var.lower()] = tag
        var_names.add(var.lower())

        # Map vars to their datatypes(TODO #13):
        if dtype in struct_names:

            for subtype in fbd_types[dtype].keys():
                var_origin[(
                    var + "." + subtype).lower()] = var + "." + subtype[:-1]
                var_names.add((var + "." + subtype).lower())
                data_types[(var + "." + subtype
                            ).lower()] = fbd_types[dtype][subtype].replace(
                                ";", '')
                if (var + "." + subtype).lower() == "hmi_p3011.permissive1":
                    print "TAG: ", tag, "; var:", var, "; \n st: ", subtype, ";\n origin: ", var + "." + subtype[:-1], "\ndata type : ", data_types[
                        (var + "." + subtype).lower()]
        else:
            data_types[var.lower()] = dtype.replace(";", '')

        var_decs = var_decs + "\t\t" + var + " : " + dtype + ";\n"
    prog_block = prog_block + initialize_messages(prj.controller.tags.members)
    del msgs_to_initialize[:]
    # Add dword helper for bit accesses
    if bit_access_helper not in var_names:
        var_decs = var_decs + "\t(*Bit Access Helper*)\n"
        var_decs = var_decs + "\t\t" + bit_access_helper + " : DWORD;\n"
        var_names.add(bit_access_helper.lower())
        var_origin[bit_access_helper.lower()] = bit_access_helper

    # Main Routine Tags (not necessary if TODO #1 implemented)
    if len(prj.programs[main_program].tags) > 0:
        var_decs = var_decs + "\t(*Main Routine Tags*)\n"
    for mtag in prj.programs[main_program].tags.members:
        tag = mtag
        var = tag
        # Make sure we're not adding duplicate var
        # while var in var_names:
        #renamed_vars[tag] = var+"_N"
        #var = renamed_vars[tag]

        dtype = prj.programs[main_program].tags.members[tag].getAttribute(
            'DataType')
        if tag in reserve_words.keys():
            var = reserve_words[tag]
            tag = reserve_words[tag]

        if var.lower() in var_names:
            continue		
        if dtype in unimplemented_types.keys():
            dtype = unimplemented_types[dtype]
        # check if this is a message that should be initialized later
        if dtype == "MESSAGE":
            msgs_to_initialize.append(var)

        #TODO #5:
        if dtype == "FBD_TIMER":
            var_decs = var_decs + "\t\t" + var + +`current_controller` +"_TMR : TON;\n"
            fbd_timers.append(var)
            reserve_words[var.lower()] = var+`current_controller`
            appended_reserved_words.append(var.lower())
            var = var + `current_controller`
        # Make sure dtype isn't renamed fbd
        #if dtype in renamed_fbds.keys():
        #dtype = renamed_fbds[dtype]
        if dtype in duplicate_fbds:
            dtype = dtype+`current_controller`
        # Keep track of where this variable name came from:
        var_origin[var.lower()] = tag
        var_names.add(var.lower())
        #TODO #13
        if dtype in struct_names:
            for subtype in fbd_types[dtype].keys():
                data_types[(var + "." + subtype
                            ).lower()] = fbd_types[dtype][subtype].replace(
                                ";", '')
                #Keep track of all subtype origins:
                var_origin[(
                    var + "." + subtype).lower()] = var + "." + subtype[:-1]
                var_names.add((var + "." + subtype).lower())
        else:
            data_types[var.lower()] = dtype.replace(";", '')
        var_decs = var_decs + "\t\t" + var + " : " + dtype + ";\n"

    #var_decs = var_decs +  "\tEND_VAR\n"
    prog_block = prog_block + initialize_messages(
        prj.programs[main_program].tags.members)

    # Add all routines as functions that aren't the main routine. This is implemented
    # only if we are using the aforementioned approach in the previous comment
    # where the main routine calls the routines as functions instead of copy
    # and pasting the routines into the main_routine  (TODO #1)
    #prog_block = prog_block +
    #for program in prj.programs.names:
    #  prog_block = prog_block + process_routines(prj.programs[program].routines,prj)

    # TODO #1: In our current approach, we only process the main routine, which
    # calls the other routines. Ideally, we would implement the other routines
    # as function calls.

    prog_block = prog_block + process_routine(
        prj.programs[main_program].routines[prj.programs[main_program]
                                            .main_routine_name], prj, "")

    # Append program termination + configuration strings
    #prog_block = prog_block + "\nEND_PROGRAM\n"+configuration
    return STFile(struct_decs, func_decs, var_decs, prog_block, l5x_file)


def parse_l5x_dir(l5xdir):
    st_file = STFile("", "", "", "", "Consolidated Program")
    l5xfiles = []
    global current_controller
    for (dirpath, dirname, fnames) in walk(l5xdir):
        for fname in fnames:
            if ".L5X" in fname:
                l5xfiles.append(dirpath + fname)
    # Assumes files are sorted in alphabetical order (P1,..,P6)
    for l5xfile in sorted(l5xfiles, key=str.lower):
        print "Parsing: ", l5xfile
        st = parse_l5x_file(l5xfile)
        st_file.add_st_content(st)
        current_controller = current_controller + 1
        remove_appended_reserved_words()
        #delete_all_var_mappings()
    #print "st_file: \n",st_file
    return st_file


#######################################
# Initialization routine
#######################################
def init():

    parser = argparse.ArgumentParser(
        description='Produces consolidated ST File.')
    group = parser.add_mutually_exclusive_group(required=True)

    parser.add_argument(
        '-o',
        metavar='ST output file',
        dest='output',
        default="output.st",
        required=False)
    group.add_argument('-i', metavar='L5X connectivity file', dest='l5xfile')
    group.add_argument('-d', metavar='L5X Directory', dest='l5xdir')
    args = parser.parse_args()
    stfile = ""
    # Parse l5x file(s)
    if args.l5xfile:
        print "Parse l5x file", args.l5xfile
        stfile = parse_l5x_file(args.l5xfile)
    elif args.l5xdir:
        stfile = parse_l5x_dir(args.l5xdir)

    outfile = open(args.output, "w")
    outfile.writelines(stfile.__str__())
    outfile.close()
    return True


#######################################
# Main routine
#######################################
if __name__ == '__main__':
    success = init()

    if success:
        print("Success!")
